# Generated by Django 4.2.17 on 2025-03-26 13:09

from django.db import migrations

# This custom data_migration translates the old registration data,
# namely:
# - Observation.registratons etc.
# - Intervention.measurement
# - Task.registrations etc.
# to the new system. This system is based on how we asked about registrations
# for tasks.

# this dictionary translates observation registration descriptions to the new
# registration pk's. The keys are the descriptions of observation registrations
# and the values the pk's of the corresponding new style registrations.

observation_registration_translation = {
    # logdata
    "logdata": 8,
    # audio-recording
    "audio-opname": 1,
    # video-recording
    "video-opname": 2,
    # notes
    "notities": 9,
    # other
    "anders": 10,
}

# let's just shorten that funny variable name
ort = observation_registration_translation


def translate_registrations(study, Registration):
    """
    A function to get the info from the old registration models into the new
    model. This requires some funk, depending on the study type.

    - Observations:
      Observation registrations need to be translated, as these registration
      models were similar but different. Therefore we have the
      observation_registration_translation dict.
    - Interventions:
      Interventions just had a textfield explaining the registration. So we
      will just select "otherwise" and add the contents of the textfield to
      study.registrations_details
    - Tasks:
      The new registrations models are ported from tasks, so these will map
      (almost) perfectly. However if multiple tasks have "other", we have to
      join the registrations_details from different tasks together ...
    """

    # We sadly can't use the get methods here, so we have to
    # reinvent them
    intervention = None
    if study.has_intervention and hasattr(study, "intervention"):
        intervention = study.intervention

    observation = None
    if study.has_observation and hasattr(study, "observation"):
        observation = study.observation

    sessions = []
    if study.has_sessions:
        sessions = study.session_set.all()

    # Create an empty dict for registrations_details and
    # registrations_kinds_details, as these can potentially
    # come from multiple sources, and we possibly have to stitch this
    # together
    reg_details_dict = {}
    reg_kinds_details_dict = {}

    # to translate intervention to the new system, we simply choose 'other'
    # as the registration type, and put the contents of the
    # Intervention.measurement into registrations_details
    if intervention:
        # 11 is the pk of the 'other' registration
        study.registrations.add(11)
        reg_details_dict["Intervention"] = intervention.measurement
        study.save()

    if observation:
        for reg in observation.registrations.all():
            # add the translated observation registration to the study
            new_reg = Registration.objects.get(pk=ort[reg.description])
            study.registrations.add(new_reg)
            # if the registration is "other", also add registrations_details
            if reg.pk == 5:
                reg_details_dict["Observation"] = observation.registrations_details
            study.save()

    if sessions:
        for session in sessions:
            for task in session.task_set.all():
                # Add the new registration models to the study using the pk's
                # of the task models, which (almost) correspond
                task_registrations_pk = [reg.pk for reg in task.registrations.all()]

                # Since we've added a new "notes" and "no registration"
                # registrations to the study registration, the new "other"
                # registration now has a pk of 11 whereas the task's old
                # "other" registration had a pk of 9, so we'll just
                # update that manually here
                task_registrations_pk = [
                    11 if pk == 9 else pk for pk in task_registrations_pk
                ]

                task_registration_kinds_pk = [
                    reg_kind.pk for reg_kind in task.registrations.all()
                ]
                study.registrations.add(*task_registrations_pk)
                study.registration_kinds.add(*task_registration_kinds_pk)
                if task.registrations_details:
                    reg_details_dict[f"Session {session.order}, Task {task.order}"] = (
                        task.registrations_details
                    )
                if task.registration_kinds_details:
                    reg_kinds_details_dict[
                        f"Session {session.order}, Task {task.order}"
                    ] = task.registration_kinds_details
                study.save()

    def process_details_dict(details_dict):
        """
        Now we just have to manage the two dicts for
        registrations_details and registration_kinds_details. If these only
        have one source, we can just put the contents into the
        study.registrations_details, we also do this if all the values are
        the same (let's say from multiple tasks with the same
        registrations_details). Otherwise we stitch them together best
        we can using the dict's keys to make some sense of this long string
        """
        if len(details_dict) == 0:
            return
        # store the first value of details_dict for later use
        first_detail = list(details_dict.values())[0]
        if len(details_dict) == 1:
            return first_detail
        # Check if all values in details_dict are exactly the same
        elif all(val == first_detail for val in details_dict.values()):
            return first_detail
        else:
            details_string = []
            for marker, details in details_dict.items():
                details_string.append(f"{marker}: {details};")
            return " ".join(details_string)

    study_registrations_details = process_details_dict(reg_details_dict)
    if study_registrations_details:
        study.registrations_details = study_registrations_details

    study_registration_kinds_details = process_details_dict(reg_kinds_details_dict)
    if study_registration_kinds_details:
        study.registration_kinds_details = study_registration_kinds_details

    study.save()


def migrate_all_registrations(apps, schema_editor):
    """
    translate the old registration for each study.
    """
    Study = apps.get_model("studies", "Study")
    Registration = apps.get_model("studies", "Registration")

    for study in Study.objects.all():
        try:
            translate_registrations(study, Registration)
        except Exception as e:
            raise RuntimeError(
                "Something went wrong with study " + str(study.pk),
            ) from e


class Migration(migrations.Migration):

    dependencies = [
        ("studies", "0037_load_registration_fixtures"),
    ]

    operations = [
        migrations.RunPython(migrate_all_registrations, migrations.RunPython.noop),
    ]
