from django.db import models
from django.contrib.auth import get_user_model
from django.utils.translation import gettext as _
from main.utils import renderable

from cdh.files.db import FileField as CDHFileField

# Create your models here.

class Attachment(models.Model, renderable):

    template_name = "attachments/attachment_model.html"
    author = models.ForeignKey(
        get_user_model(),
        related_name="created_attachments",
        null=True,
        on_delete=models.SET_NULL,
        default=None,
    )
    upload = CDHFileField(
        verbose_name=_("Bestand"),
        help_text=_("Selecteer hier het bestand om toe te voegen."),
    )
    parent = models.ForeignKey(
        "attachments.attachment",
        related_name="children",
        null=True,
        on_delete=models.SET_NULL,
        default=None,
    )
    kind = models.CharField(
        max_length=100,
        default=("", _("Gelieve selecteren")),
    )
    name = models.CharField(
        max_length=50,
        default="",
        help_text=_(
            "Geef je bestand een omschrijvende naam, het liefst "
            "maar enkele woorden."
        )
    )
    comments = models.TextField(
        max_length=2000,
        default="",
        help_text=_(
            "Geef hier optioneel je motivatie om dit bestand toe te voegen en "
            "waar "
            "je het voor gaat gebruiken tijdens je onderzoek. Eventuele "
            "opmerkingen voor de FETC kun je hier ook kwijt."
        )
    )

    def get_correct_submodel(self):
        from attachments.utils import get_kind_from_str
        kind = get_kind_from_str(self.kind)
        # By default, this is how subclassed model relation names
        # are generated by Django. That's why the following line works.
        # However, if we use a different related_name or a name
        # collision we'd have to be smarter about getting the submodel.
        key = kind.attachment_class.__name__.lower()
        return getattr(self, key)

    def detach(self, other_object):
        """
        This method is simple enough to define for all submodels,
        assuming they use the attached_to attribute name. However,
        base Attachments do not have an attached_to attribute, so
        we have to defer to the submodel if detach is called on a
        base Attachment instance.
        """
        if self.__name__ == "Attachment":
            attachment = self.get_correct_submodel()
            return attachment.detach(other_object)
        # The following part only runs if called from a submodel
        if self.attached_to.count > 1:
            self.attached_to.remove(other_object)
        else:
            self.delete()

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["attachment"] = self
        return context

class ProposalAttachment(Attachment,):
    attached_to = models.ManyToManyField(
        "proposals.Proposal",
        related_name="attachments",
    )

    def get_owner_for_proposal(self, proposal,):
        """
        This method doesn't do much, it's just here to provide
        a consistent interface for getting owner objects.
        """
        return proposal

class StudyAttachment(Attachment,):
    attached_to = models.ManyToManyField(
        "studies.Study",
        related_name="attachments",
    )

    def get_owner_for_proposal(self, proposal,):
        """
        Gets the owner study based on given proposal.
        """
        return self.attached_to.get(proposal=proposal)
